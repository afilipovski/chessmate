# Вовед

ChessMate е имплементација на познатата игра шах како Windows Forms апликација. Играчите смеат да играат против вештачка интелигенција (Alpha-Beta Pruning алгоритмот) и multiplayer противник.

![Animation](https://i.imgur.com/nbhaZQk.gif)


# Како се користи?

По стартување на апликацијата се прикажува почетниот екран, на кој се дадени 3 копчиња: About, AI Opponent и Multiplayer. Притискање на секое копче отвара нов екран. About копчето отвара екран со информации за апликацијата, AI Opponent отвара екран за игра против вештачка интелигенција и Multiplayer отвара екран за приклучување кон multiplayer игра.

Кога играчот игра против вештачка интелигенција, на екранот се прикажува шаховска табла во центарот и мени на врвот. Играчот секогаш започнува прв, па белите фигури се негови и се наоѓаат на долниот дел од таблата, а црните на горниот. Во менито се наоѓаат 2 копчиња: File и Opponent. При притиснување на некое од копчињата во менито, под менито се појавуваат други копчиња за подесување на состојбата на играта. Копчето Opponent овозможува подесување на тежината на вештачката интелигенција (Easy, Medium, Hard), а File овозможува: започнување нова игра, зачувување на тековната состојба на играта во нов документ, вчитување на состојба од постоечки документ и напуштање на играта.

За приклучување кон multiplayer игра, играчот внесува негово корисничко име (задолжително) и код за приклучување кон играта (опционално). Доколку корисникот не внесе код, се создава нова игра во која тој е прв и чека друг играч да се приклучи, а во спровино се приклучува кон постоечка игра. Без разлика на редоследот на играчите, за секој играч, неговите фигури од негов поглед се прикажани на долниот дел од шаховската табла. Ако еден од играчите се откаже од играта, другиот играч автоматски победува и играта се затвара. По затварање на играта повторно се појавува екранот за приклучување кон multiplayer.  

Без разлика на типот противник, кога играчот стиска на една од неговите фигури, апликацијата ги одредува и означува со зелена боја сите позиции кадешто избраната фигура може да застане. Правилата за валидни позиции на секоја фигура се исти како тие од обичниот шах. Опфатени се и сите специјални потези (промоција на пион, *en passant*, рокада). Додека се чека за потег од противникот, врз шаховската табла се исцртува пораката „Opponent turn...“.

# Опис на техничкото решение
Имплементацијата на проектот се состои од користење разни класи, објекти и слики.

Во папката Pieces се наоѓаат класи за сите можни фигури на играта (Pawn, Knight, Bishop, Rook, King, Queen). Сите класи наследуваат од апстрактната класа Piece и ги имплементираат нејзините апстрактни методи (PossibleMoves, GetBitmap, Clone). Специјален случај е класата ContinuousPathPiece, која наследува од Piece и е наследена од Rook, Bishop и Queen. 

Визуелниот изглед на секоја фигура е даден во папката PieceImages. Апстрактниот метод GetBitmap на секоја фигура е задолжен за избирање на соодветната слика.

Кодот за вештачката имплементација стои во папката AlphaBeta. Класата Opponent ја симулира вештачката интелигенција, давајќи потези преку методот Move, кој ги повикува статичките методи од EvaluationUtils.   

Папката Interface содржи класи за работење со исцртување на фигури и прикажување пораки на екранот.

Класата Position се користи за означување на позиција од шаховската табла со X и Y координати (двете меѓу 0 и 7). Оските се исти како тие во Windows Forms. Изведената класа ColoredPosition служи за означување на постоечка позиција како зелена при означување на дозволени позиции на одбрана фигура. Специјалните потези се обележани со сина боја, додека црвената боја служи за означување на шах-позиција.

Класата Board ја претставува шаховската табла. Секоја позиција, како и соодветната фигура на таа позција, се чува во хеш табела. Според потребите на вештачката интелигенција, секогаш кога се генерира нов валиден потег на фигура, тој потег ќе претставува нова табла што е изведена од deep copy на претходната (вклучувајќи ги сите фигури и позиции). Долниот код ги илустрира опишаните концепти за таблата. Така, вештачката интелигенција врши гранење на секој можен потег (до максимално дозволената длабочина на дрвото) и според оценувањата го бира најдобриот. Дополнително, класата Board содржи и методи за означување на новата позиција на поместената фигура (NewPos), метод за генерирање на сите нови можни потези (Successor) и метод за одредување дали кралот е под ризик да биде фатен во една од новите позиции (KingIsInCheck).

```c#
public class Board
{
	public Dictionary<Position, Piece> PieceByPosition { get; set; }
	public ColoredPosition NewPos { get; set; }

	public Board(Board board)
	{
		PieceByPosition = new Dictionary<Position, Piece>();
		WhiteTurn = !board.WhiteTurn;
		foreach (Position key in board.PieceByPosition.Keys)
		{
			if (board.PieceByPosition[key] != null)
			    PieceByPosition[key] = board.PieceByPosition[key].Clone();
			else
			    PieceByPosition[key] = null;
		}
		TurnNumber = board.TurnNumber + 1;
	}

	public Board(Board b, Position posOld, Position posNew, Piece p) : this(b)
	{
		p = p.Clone();
		NewPos = new ColoredPosition(posNew);
		PieceByPosition[posNew] = p;
		PieceByPosition[posOld] = null;
		PieceByPosition[posNew].Position = posNew;
	}
}
```
Класата Form1.cs го содржи кодот на формата Form1. Содржи методи за справување со настани за кликање на различни елементи и настани за исцртување на шаховската табла. За да се овозможи зачувување на состојбата на моменталната игра, сите корисничко дефинирани класи како Piece, Board и Position се декларирани за серијализација со анотацијата Serializable.

# Опис на класата Queen

Во продолжените е даден краток опис на класата Queen. Кралицата наследува од класата ContionuousPathPiece и имплементира сопствен конструктор и методите Clone, GetBitMap и PossibleMoves. Со оглед на тоа што кралицата ги имат истите потези на топот и лоцецот, во методот PossibleMoves кралицата преку copy конструктор се претвара во Bishop и Rook објекти. После, овие објекти се заменуваат во предадениот Board објект на местото на кралицата и се повикува PossibleMoves методот на двата објекти. За секоја нова создадена шаховска табела, на позицијата кадешто би застанала мрднатата фигура се става deep copy од кралицата. Сите нови шаховски табли се додаваат во листата што ја враќа методот.

# Alpha-Beta pruning

AI противникот е имплементиран со помош на Minimax правилото на одлучување, со кое алгоритамот ги разгледува сите состојби на шаховската табла кои може да произлезат од моменталнтата, градејќи дрво составено од јазли чиишто потомци се можните состојби по следниот чекор. Оценувањето на состојбата на шаховската табла се состои од едноставно вреднување на секоја од фигурите, и сумирање на вредностите.

Оценките за можните резултантни состојби ги користиме за одлучување кој чекор е најперспективен, гледајќи 1 (Easy), 2 (Medium) или 3 (Hard) чекори унапред. Alpha-Beta Pruning се употребува за да се идентификуваат ситуациите во дрвото каде негово понатамошно продлабочување би било излишно. Во продолжение да разгледаме пример за таков случај:

![image](https://i.imgur.com/r80uNYg.png)

*Слика 1. Го разгледуваме првото одлево поткастрување на дрвото. (Илустративно, не се сретнува во имплементацијата на шах)*

Јазелот 5 на длабочина 2 (max) го разгледал своето лево поддрво и добил вредност
$\alpha = 5$. Потоа, разгледувајќи го десното дрво, наидуваме на вредност 4. Бидејќи секое понатамошно разгледување на поддрва ќе ни даде резултат <=4, а ни е потребен резултат $> \alpha$, ги поткаструваме сите понатамошни „гранки“ на min-јазелот.

Логички следува дека ваквата оптимизација ќе го даде истиот резултат како и обичен Minimax, меѓутоа во пократко време. Сепак, [програмирањето на AI за шах](https://en.wikipedia.org/wiki/Chess_engine) е сложен процес во кој може да се применат голем број на евристики и специјализирано знаење за да се добијат подобри резултати. Нашиот AI, како многу основна имплементација на chess engine, често генерира подоптимални чекори. За најдобри резултати препорачуваме проектот да го изградите со Release конфигурација, и AI противникот да го сетирате на Hard.

# Изработиле

* Aлександар Филиповски (211047)
* Димитриј Крстев (213171)
* Иван Цекиќ (211146)
