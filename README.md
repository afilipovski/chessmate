# Вовед

ChessMate е имплементација на познатата игра шах како Windows Forms апликација. Играчите смеат да играат против вештачка интелигенција (Alpha-Beta Pruning алгоритмот) и multiplayer противник.

![Animation](https://i.imgur.com/nbhaZQk.gif)


# Како се користи?

По стартување на апликацијата се прикажува почетниот екран, на кој се дадени 3 копчиња: About, AI Opponent и Multiplayer. Притискање на секое копче отвара нов екран. About копчето отвара екран со информации за апликацијата, AI Opponent отвара екран за игра против вештачка интелигенција и Multiplayer отвара екран за приклучување кон multiplayer игра.

Кога играчот игра против вештачка интелигенција, на екранот се прикажува шаховска табла во центарот и мени на врвот. Играчот секогаш започнува прв, па белите фигури се негови и се наоѓаат на долниот дел од таблата, а црните на горниот. Во менито се наоѓаат 2 копчиња: File и Opponent. При притиснување на некое од копчињата во менито, под менито се појавуваат други копчиња за подесување на состојбата на играта. Копчето Opponent овозможува подесување на тежината на вештачката интелигенција (Easy, Medium, Hard), а File овозможува: започнување нова игра, зачувување на тековната состојба на играта во нов документ, вчитување на состојба од постоечки документ и напуштање на играта.

За приклучување кон multiplayer игра, играчот внесува негово корисничко име (задолжително) и код за приклучување кон играта (опционално). Доколку корисникот не внесе код, се создава нова игра во која тој е прв и чека друг играч да се приклучи, а во спровино се приклучува кон постоечка игра. Без разлика на редоследот на играчите, за секој играч, неговите фигури од негов поглед се прикажани на долниот дел од шаховската табла. Ако еден од играчите се откаже од играта, другиот играч автоматски победува и играта се затвара. По затварање на играта повторно се појавува екранот за приклучување кон multiplayer.  

Без разлика на типот противник, кога играчот стиска на една од неговите фигури, апликацијата ги одредува и означува со зелена боја сите позиции кадешто избраната фигура може да застане. Правилата за валидни позиции на секоја фигура се исти како тие од обичниот шах. Опфатени се и сите специјални потези (промоција на пион, *en passant*, рокада). Додека се чека за потег од противникот, врз шаховската табла се исцртува пораката „Opponent turn...“.

# Опис на техничкото решение

Апликацијата е структурирана според слоевита архитектура (доменски, сервисен и презентациски слој). Во сервисниот и презентацискиот слој дел од компонентите применуваат шаблони за развој на софтвер. За менаџирање една инстанца од класа се имплементира singleton шаблонот преку наследување на класата SingletonBase. Кадешто има потреба од loose-coupling меѓу компоненти се имплементира интерфејс за повици. MVC шаблонот се применува за да се разделат формите, реагирањето на барања од настани и податоците што се ажурираат.

Без разлика на типот противник, имплементацијата се базира на истите компоненти. 

Во папката Domain.Pieces се наоѓаат класи за сите можни фигури на играта (Pawn, Knight, Bishop, Rook, King, Queen). Сите класи наследуваат од апстрактната класа Piece и ги имплементираат нејзините апстрактни методи (PossibleMoves, Name, Clone). Специјален случај е класата ContinuousPathPiece, која наследува од Piece и е наследена од Rook, Bishop и Queen.

Визуелниот изглед на секоја фигура е даден во папката Presentation.Images. Класата Position се користи за означување на позиција од шаховската табла со X и Y координати (двете меѓу 0 и 7). Изведената класа ColoredPosition служи за означување на постоечка позиција во боја во специјални случаи (црвена за позицијата на кралот кога е во мат, плава за позиции на специјални потези, зелена за сите останати потези на фигурите).

Класата Board ја претставува шаховската табла. Секоја позиција, како и соодветната фигура на таа позција, се чува во хеш табела. Според потребите на вештачката интелигенција, секогаш кога се генерира нов валиден потег на фигура, тој потег ќе претставува нова табла што е изведена од deep copy на претходната (вклучувајќи ги сите фигури и позиции). Така, вештачката интелигенција врши гранење на секој можен потег (до максимално дозволената длабочина на дрвото) и според оценувањата го бира најдобриот. Овој механизам за генерирање потези е реискористен и за multiplayer. Дополнително, класата Board содржи и атрибут за означување на новата позиција на поместената фигура (NewPos).

Правилата за управување со играта (правила за шаховска табла, зачувување/вчитување на состојбата на игра против вештачка интелигенција, поврзување за multiplayer) се дадени во сервисниот слој.

Кодот за вештачката имплементација стои во папката Presentation.AlphaBeta. Класата Opponent ја симулира вештачката интелигенција, давајќи потези преку методот Move, кој ги повикува статичките методи од EvaluationUtils.   

Формите се наоѓаат во папката Presentation.Interface. При активирање на некој настан, формите ја предаваат логиката на контролери да ја извршат. Контролерите се наоѓаат во папката Domain.Controllers и ја менаџираат состојбата на податоците, користат исцртувачи на објекти, се справуваат со исклучоци и применуваат сервисни функционалности.

Исцртувањето на објекти (порака за потег, шаховска табла, позиции, фигури) е дадено во папката Presentation.GraphicsRendering.

# Alpha-Beta pruning

AI противникот е имплементиран со помош на Minimax правилото на одлучување, со кое алгоритамот ги разгледува сите состојби на шаховската табла кои може да произлезат од моменталнтата, градејќи дрво составено од јазли чиишто потомци се можните состојби по следниот чекор. Оценувањето на состојбата на шаховската табла се состои од едноставно вреднување на секоја од фигурите, и сумирање на вредностите.

Оценките за можните резултантни состојби ги користиме за одлучување кој чекор е најперспективен, гледајќи 1 (Easy), 2 (Medium) или 3 (Hard) чекори унапред. Alpha-Beta Pruning се употребува за да се идентификуваат ситуациите во дрвото каде негово понатамошно продлабочување би било излишно. Во продолжение да разгледаме пример за таков случај:

![image](https://i.imgur.com/r80uNYg.png)

*Слика 1. Го разгледуваме првото одлево поткастрување на дрвото. (Илустративно, не се сретнува во имплементацијата на шах)*

Јазелот 5 на длабочина 2 (max) го разгледал своето лево поддрво и добил вредност
$\alpha = 5$. Потоа, разгледувајќи го десното дрво, наидуваме на вредност 4. Бидејќи секое понатамошно разгледување на поддрва ќе ни даде резултат <=4, а ни е потребен резултат $> \alpha$, ги поткаструваме сите понатамошни „гранки“ на min-јазелот.

Логички следува дека ваквата оптимизација ќе го даде истиот резултат како и обичен Minimax, меѓутоа во пократко време. Сепак, [програмирањето на AI за шах](https://en.wikipedia.org/wiki/Chess_engine) е сложен процес во кој може да се применат голем број на евристики и специјализирано знаење за да се добијат подобри резултати. Нашиот AI, како многу основна имплементација на chess engine, често генерира подоптимални чекори. За најдобри резултати препорачуваме проектот да го изградите со Release конфигурација, и AI противникот да го сетирате на Hard.

# Multiplayer

Multiplayer-от е имплементиран преку web сервер. Серверот е напишан во PHP со Laravel, и користи пакет за шаховска логика за дополнителна верификација на чекорите на играчот. Ажурирањето на статусот на играта се врши преку HTTP Regular Polling. Кодот е структуриран за во иднина истото може да се замени со WebSocket комуникација. Веб интерфејсот поддржува земање CSRF токен, пребарување на игра, креирање игра, правење потег, како и приклучување кон и напуштање на игра.

# Како да се изврши?

1. Симнете и инсталирајте го Microsoft Visual Studio.
2. При инсталација, одберете го пакетот „.NET desktop development“.
3. Отворете го solution-от во Visual Studio.
4. Изградете го одново solution-от.
5. Притиснете го Run копчето.

# Изработиле

* Aлександар Филиповски (211047)
* Димитриј Крстев (213171)
* Иван Цекиќ (211146)
